//TComp SortedIndexedList::remove(int i) {
//    if (i < 0 || i >= this->sizeTree) {
//        throw std::invalid_argument("Invalid position in the list!");
//    }
//
//    Node* currentNode = this->root;
//    while (currentNode != nullptr) {
//        int leftSize = currentNode->nrLeftElements;
//        if (i == leftSize) {
//            break;
//        } else if (i < leftSize) {
//            currentNode = currentNode->left;
//        } else {
//            i = i - leftSize - 1;
//            currentNode = currentNode->right;
//        }
//    }
//
//    TComp removedElement = currentNode->info;
//
//    if (currentNode->left == nullptr && currentNode->right == nullptr) {
//        if (currentNode == this->root) {
//            this->root = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = nullptr;
//            } else {
//                parentNode->right = nullptr;
//            }
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else if (currentNode->left == nullptr) {
//        if (currentNode == this->root) {
//            this->root = currentNode->right;
//            this->root->parent = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = currentNode->right;
//            } else {
//                parentNode->right = currentNode->right;
//            }
//            currentNode->right->parent = parentNode;
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else if (currentNode->right == nullptr) {
//        if (currentNode == this->root) {
//            this->root = currentNode->left;
//            this->root->parent = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = currentNode->left;
//            } else {
//                parentNode->right = currentNode->left;
//            }
//            currentNode->left->parent = parentNode;
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else {
//        Node* successorNode = currentNode->right;
//        while (successorNode->left != nullptr) {
//            successorNode = successorNode->left;
//        }
//        currentNode->info = successorNode->info;
//        if (successorNode->right != nullptr) {
//            successorNode->right->parent = successorNode->parent;
//        }
//        if (successorNode->parent->left == successorNode) {
//            successorNode->parent->left = successorNode->right;
//        } else {
//            successorNode->parent->right = successorNode->right;
//        }
//        this->updateNrLeftElements(successorNode->parent);
//        delete successorNode;
//    }
//
//    this->sizeTree--;
//    return removedElement;
//}


//TComp SortedIndexedList::remove(int pos) {
//    if (pos < 0 || pos >= this->sizeTree) {
//        throw invalid_argument("Invalid position in the list!");
//    }
//
//    Node* currentNode = this->root;
//    while (currentNode != nullptr) {
//        int leftSize = currentNode->nrLeftElements;
//        if (pos == leftSize) {
//            break;
//        } else if (pos < leftSize) {
//            currentNode = currentNode->left;
//        } else {
//            pos = pos - leftSize - 1;
//            currentNode = currentNode->right;
//        }
//    }
//
//    TComp removedElement = currentNode->info;
//
//    // Update the condition to check if the element's value matches the position
//    if (removedElement == pos) {
//        if (currentNode->left == nullptr && currentNode->right == nullptr) {
//            // Handle the case when the node has no children
//            if (currentNode == this->root) {
//                this->root = nullptr;
//            } else {
//                Node* parentNode = currentNode->parent;
//                if (parentNode->left == currentNode) {
//                    parentNode->left = nullptr;
//                } else {
//                    parentNode->right = nullptr;
//                }
//                this->updateNrLeftElements(parentNode);
//            }
//            delete currentNode;
//        } else {
//            // Handle the case when the node has one child
//            Node* childNode;
//            if (currentNode->left != nullptr) {
//                childNode = currentNode->left;
//            } else {
//                childNode = currentNode->right;
//            }
//
//            if (currentNode == this->root) {
//                this->root = childNode;
//                this->root->parent = nullptr;
//            } else {
//                Node* parentNode = currentNode->parent;
//                if (parentNode->left == currentNode) {
//                    parentNode->left = childNode;
//                } else {
//                    parentNode->right = childNode;
//                }
//                childNode->parent = parentNode;
//                this->updateNrLeftElements(parentNode);
//            }
//            delete currentNode;
//        }
//    }
//
//    this->sizeTree--;
//    return removedElement;
//}

//TComp SortedIndexedList::remove(int i) {
//    if (i < 0 || i >= this->sizeTree) {
//        throw std::invalid_argument("Invalid position in the list!");
//    }
//
//    Node* currentNode = this->root;
//    while (currentNode != nullptr) {
//        int leftSize = currentNode->nrLeftElements;
//        if (i == leftSize) {
//            break;
//        } else if (i < leftSize) {
//            currentNode = currentNode->left;
//        } else {
//            i = i - leftSize - 1;
//            currentNode = currentNode->right;
//        }
//    }
//
//    TComp removedElement = currentNode->info;
//
//    if (currentNode->left == nullptr && currentNode->right == nullptr) {
//        if (currentNode == this->root) {
//            this->root = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = nullptr;
//            } else {
//                parentNode->right = nullptr;
//            }
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else if (currentNode->left == nullptr) {
//        if (currentNode == this->root) {
//            this->root = currentNode->right;
//            this->root->parent = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = currentNode->right;
//            } else {
//                parentNode->right = currentNode->right;
//            }
//            currentNode->right->parent = parentNode;
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else if (currentNode->right == nullptr) {
//        if (currentNode == this->root) {
//            this->root = currentNode->left;
//            this->root->parent = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = currentNode->left;
//            } else {
//                parentNode->right = currentNode->left;
//            }
//            currentNode->left->parent = parentNode;
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else {
//        Node* successorNode = currentNode->right;
//        while (successorNode->left != nullptr) {
//            successorNode = successorNode->left;
//        }
//        currentNode->info = successorNode->info;
//
//        // Update nrLeftElements values for the affected nodes
//        if (successorNode->parent->left == successorNode) {
//            successorNode->parent->left = successorNode->right;
//            if (successorNode->right != nullptr) {
//                successorNode->right->parent = successorNode->parent;
//            }
//            this->updateNrLeftElements(successorNode->parent);
//        } else {
//            successorNode->parent->right = successorNode->right;
//            if (successorNode->right != nullptr) {
//                successorNode->right->parent = successorNode->parent;
//            }
//            this->updateNrLeftElements(successorNode->parent);
//        }
//        delete successorNode;
//    }
//
//    this->sizeTree--;
//    return removedElement;
//}





//TComp SortedIndexedList::remove(int i) {
//    if (i < 0 || i >= this->sizeTree) {
//        throw std::invalid_argument("Invalid position in the list!");
//    }
//
//    Node* currentNode = this->root;
//    while (currentNode != nullptr) {
//        int leftSize = currentNode->nrLeftElements;
//        if (i == leftSize) {
//            break;
//        } else if (i < leftSize) {
//            currentNode = currentNode->left;
//        } else {
//            i = i - leftSize - 1;
//            currentNode = currentNode->right;
//        }
//    }
//
//    TComp removedElement = currentNode->info;
//
//    if (currentNode->left == nullptr && currentNode->right == nullptr) {
//        if (currentNode == this->root) {
//            this->root = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = nullptr;
//            } else {
//                parentNode->right = nullptr;
//            }
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else if (currentNode->left == nullptr) {
//        if (currentNode == this->root) {
//            this->root = currentNode->right;
//            this->root->parent = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = currentNode->right;
//            } else {
//                parentNode->right = currentNode->right;
//            }
//            currentNode->right->parent = parentNode;
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else if (currentNode->right == nullptr) {
//        if (currentNode == this->root) {
//            this->root = currentNode->left;
//            this->root->parent = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = currentNode->left;
//            } else {
//                parentNode->right = currentNode->left;
//            }
//            currentNode->left->parent = parentNode;
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else {
//        Node* successorNode = currentNode->right;
//        while (successorNode->left != nullptr) {
//            successorNode = successorNode->left;
//        }
//        currentNode->info = successorNode->info;
//        if (successorNode->right != nullptr) {
//            successorNode->right->parent = successorNode->parent;
//        }
//        if (successorNode->parent->left == successorNode) {
//            successorNode->parent->left = successorNode->right;
//        } else {
//            successorNode->parent->right = successorNode->right;
//        }
//        this->updateNrLeftElements(successorNode->parent);
//        delete successorNode;
//    }
//
//    this->sizeTree--;
//    return removedElement;
//}
