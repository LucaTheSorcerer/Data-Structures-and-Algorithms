//TComp SortedIndexedList::remove(int i) {
//    if (i < 0 || i >= this->sizeTree) {
//        throw std::invalid_argument("Invalid position in the list!");
//    }
//
//    Node* currentNode = this->root;
//    while (currentNode != nullptr) {
//        int leftSize = currentNode->nrLeftElements;
//        if (i == leftSize) {
//            break;
//        } else if (i < leftSize) {
//            currentNode = currentNode->left;
//        } else {
//            i = i - leftSize - 1;
//            currentNode = currentNode->right;
//        }
//    }
//
//    TComp removedElement = currentNode->info;
//
//    if (currentNode->left == nullptr && currentNode->right == nullptr) {
//        if (currentNode == this->root) {
//            this->root = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = nullptr;
//            } else {
//                parentNode->right = nullptr;
//            }
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else if (currentNode->left == nullptr) {
//        if (currentNode == this->root) {
//            this->root = currentNode->right;
//            this->root->parent = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = currentNode->right;
//            } else {
//                parentNode->right = currentNode->right;
//            }
//            currentNode->right->parent = parentNode;
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else if (currentNode->right == nullptr) {
//        if (currentNode == this->root) {
//            this->root = currentNode->left;
//            this->root->parent = nullptr;
//        } else {
//            Node* parentNode = currentNode->parent;
//            if (parentNode->left == currentNode) {
//                parentNode->left = currentNode->left;
//            } else {
//                parentNode->right = currentNode->left;
//            }
//            currentNode->left->parent = parentNode;
//            this->updateNrLeftElements(parentNode);
//        }
//        delete currentNode;
//    } else {
//        Node* successorNode = currentNode->right;
//        while (successorNode->left != nullptr) {
//            successorNode = successorNode->left;
//        }
//        currentNode->info = successorNode->info;
//        if (successorNode->right != nullptr) {
//            successorNode->right->parent = successorNode->parent;
//        }
//        if (successorNode->parent->left == successorNode) {
//            successorNode->parent->left = successorNode->right;
//        } else {
//            successorNode->parent->right = successorNode->right;
//        }
//        this->updateNrLeftElements(successorNode->parent);
//        delete successorNode;
//    }
//
//    this->sizeTree--;
//    return removedElement;
//}
